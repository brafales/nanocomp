/*
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
                                                                          */

// $Revision: 1.8 $

#include "layoutDiskManager.hpp"
#include "flexDefines.hpp"
#include <fstream>

//! Constructor.
/*!
  \param controller the space controller.
*/
LayoutDiskManager::LayoutDiskManager(LayoutManager *controller)
{
    this->controller = controller;
}


//! Destructor.
LayoutDiskManager::~LayoutDiskManager()
{
}


//! Saves a space into a file.
/*!
   \param layoutConfig space to be saved.
   \param fileName the file name where to save.
   \return True iif the space was correctly saved.
*/
bool LayoutDiskManager::saveLayout(LayoutConfig *layoutConfig, wxString fileName)
{
    if (wxFile::Exists(fileName))
    {
        file.Open(fileName);
    }
    else
    {
        file.Create(fileName);   
    }
    file.Clear();
    if (!saveLayout(layoutConfig))
    {
        file.Close();
        return false;
    }
    if (!file.Write(wxTextFileType_Unix))
    {
        file.Close();
        return false;
    }
    return (file.Close());
}


//! Saves a space.
/*!
   The space is saved to the corresponding file
   previously opened.
  \param layoutConfig the space to be saved.
  \return True iif the space was correctly saved.
*/
bool LayoutDiskManager::saveLayout(LayoutConfig *layoutConfig)
{
    bool result = true;
    file.AddLine(_("#Space file created by Nanocomp."));
    file.AddLine(_("#Do not edit this file if you don't know what are you doing."));
    file.AddLine(wxEmptyString);
    
    file.AddLine(wxString::Format(_("%d %d"), layoutConfig->getWidth(), layoutConfig->getHeight()));
    file.AddLine(wxEmptyString);
    result = result && saveGrid(layoutConfig->getGrid());
    
    file.AddLine(wxEmptyString);
    file.AddLine(_("#End of file"));
    return result;
}


//! Saves a grid.
/*!
  \param grid the grid to be saved.
  \return True iif the grid was correctly saved.
*/
bool LayoutDiskManager::saveGrid(Grid grid)
{
    //See the CA space format for details
    wxChar inputs = 'a';
    wxChar outputs = 'A';
    wxString space = wxEmptyString;
    for(int i = 0; i < grid.getHeight(); i++)
    {
        wxString line = space;
        for(int j = 0; j < grid.getWidth(); j++)
        {
            wxString status;
            
            switch (grid(j, i))
            {
                case nNOSPACE:
                {
                    line = line + _("-");
                    break;
                }
                case nENABLED:
                {
                    line = line + _("1");
                    break;
                }
                case nDISABLED:
                {
                    line = line + _("0");
                    break;
                }
                case nINPUT:
                {
                    line = line + inputs;
                    inputs++;
                    break;
                }
                case nOUTPUT:
                {
                    line = line + outputs;
                    outputs++;
                    break;
                }
                case nDONTCARE:
                {
                    line = line + _(".");
                    break;
                }
                default:
                {
                }
            }
            
            //Add the space between cells (except if last)
            if(j != grid.getWidth() - 1)
            {
                for (int l = 0; l < CELL_SPACE; l++)
                {
                    line += _(" ");
                }
            }
        }
        file.AddLine(line);
        //Add the line tabulation for each line
        for (int k = 0; k < LINE_SPACE; k++)
        {
            space += _(" ");
        }
    }
    return true;
}


//! Opens a space file.
/*!
  \param fileName the file to be opened.
  \return True iif the file was correctly opened.
*/
bool LayoutDiskManager::openLayout(wxString fileName)
{
    LayoutConfig *layoutConfig;
    filebuf fb;
    if (!fb.open (fileName.mb_str(), ios::in))
    {
        return false;
    }
    istream *is = new istream(&fb);
    int result;
    int width;
    int height;
    FlexLexer* lexer = new yyFlexLexer();
    lexer->switch_streams(is, NULL);
    result = lexer->yylex();
    while (result != 0)
    {
        if (result != NUMBER)
        {
            //Number expected, error
            delete is;
            delete lexer;
            fb.close();
            return false;
        }
        else
        {
            width = atoi(lexer->YYText());
            if (lexer->yylex() != NUMBER) //Not another number
            {
                //Number expected, error
                delete is;
                delete lexer;
                fb.close();
                return false;
            }
            else
            {
                height = atoi(lexer->YYText());
                layoutConfig = readLayout(width, height, lexer);
                if (!layoutConfig)
                {
                    delete is;
                    delete lexer;
                    fb.close();
                    return false;
                }
            }
        }
        result = lexer->yylex();
    }
    fb.close();
    returnLayout(layoutConfig);
 
    return true;
}


//! Reads a space from a lexer.
/*!
   This method reads a width*height space from the
   lexer.
  \param width expected width of the space to be read.
  \param height expected height of the space to be read.
  \param lexer lexer containing the stream where to read.
  \return The space read. NULL if the space couldn't be read.
*/
LayoutConfig* LayoutDiskManager::readLayout(int width, int height, FlexLexer *lexer)
{
    Grid cells(width, height);
    int inputs = 0;
    int outputs = 0;
    //Now we have to process width * height cells
    int result;
    for(int i = 0; i < width * height; i++)
    {
        switch (result = lexer->yylex())
        {
            case NUMBER: //Number, so must be 1 or 0, else error
                {
                    if (atoi(lexer->YYText()) != 1 && atoi(lexer->YYText()) != 0)
                    {
                        //0 or 1 expected, file format error
                        return false;
                    }
                    else
                    {
                        if (atoi(lexer->YYText()) == 1)
                        {
                            cells(i - width * (i/width), i/width) = nENABLED;
                        }
                        else
                        {
                            cells(i - width * (i/width), i/width) = nDISABLED;
                        }
                    }
                    break;
                }
            case POINT: 
                {
                    cells(i - width * (i/width), i/width) = nDONTCARE;
                    break;
                }
            case SLASH:
                {
                    cells(i - width * (i/width), i/width) = nNOSPACE;
                    break;
                }
            case UPPER:
                {
                    cells(i - width * (i/width), i/width) = nOUTPUT;
                    outputs++;
                    break;
                }
            case LOWER:
                {
                    cells(i - width * (i/width), i/width) = nINPUT;
                    inputs++;
                    break;
                }
            default: //Error
                {
                    return false;
                }
        }
    }
    
    //Now we know inputs and outputs
    LayoutConfig *layoutConfig = new LayoutConfig(width, height, inputs, outputs);
    
    
    for(int i = 0; i < height; i++)
    {
        for(int j = 0; j < width; j++)
        {
            layoutConfig->cellChanged(j, i, cells(j, i));
        }
    }

    return layoutConfig;
}


//! Returns a space to the controller.
/*!
   \param layoutConfig the space to be added.
*/
void LayoutDiskManager::returnLayout(LayoutConfig *layoutConfig)
{
    controller->newLayout(layoutConfig);
}
