/*
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
                                                                          */

// $Revision: 1.7 $

#include "truthTableDiskManager.hpp"
#include "flexDefines.hpp"
#include <fstream>
#include <math.h>

//! Constructor.
/*!
   \param controller the truth table controller.
*/
TruthTableDiskManager::TruthTableDiskManager(TruthTableManager *controller)
{
    this->controller = controller;
}


//! Destructor.
TruthTableDiskManager::~TruthTableDiskManager()
{
}


//! Saves the table collection to a file.
/*!
   \param tables the table collection.
   \param fileName the file name to be saved.
   \return True iif the tables were saved correctly.
*/
bool TruthTableDiskManager::saveTables(list<TruthTable*> tables, wxString fileName)
{
    if (wxFile::Exists(fileName))
    {
        file.Open(fileName);
    }
    else
    {
        file.Create(fileName);   
    }
    file.Clear();
    if (!saveTableList(tables))
    {
        file.Close();
        return false;
    }
    if (!file.Write(wxTextFileType_Unix))
    {
        file.Close();
        return false;
    }
    return (file.Close());
}


//! Saves a table list to the file.
/*!
   \param tables the table list.
   \return True iif the table list was saved correctly.
*/
bool TruthTableDiskManager::saveTableList(list<TruthTable*> tables)
{
    bool result = true;
    file.AddLine(_("#Truth Table file created by Nanocomp."));
    file.AddLine(_("#Do not edit this file if you don't know what are you doing."));
    file.AddLine(wxEmptyString);
    for(list<TruthTable*>::iterator i = tables.begin(); i != tables.end(); i++)
    {
        result = result && saveTable((*i));
    }
    file.AddLine(_("#End of file"));
    return result;
}


//! Saves a table to the file.
/*!
   \param table table to be saved.
   \return True iif the table was saved correctly.
*/
bool TruthTableDiskManager::saveTable(TruthTable *table)
{
    file.AddLine(table->getName());
    file.AddLine(wxString::Format(_("%d %d"), table->getInputs(), table->getOutputs()));
    saveVector(table->getTable());
    file.AddLine(wxEmptyString);
    return true;
}


//! Saves a boolean vector to the file.
/*!
   \param booleans the boolean vector to save.
   \return True iif the vector was saved correctly.
*/
bool TruthTableDiskManager::saveVector(vector< vector<bool> > booleans)
{
    for(unsigned int i = 0; i < booleans.size(); i++)
    {
        for (unsigned int j = 0; j < booleans[i].size(); j++)
        {
            if (booleans[i][j])
            {
                file.AddLine(_("1"));
            }
            else
            {
                file.AddLine(_("0"));
            }
        }
    }
    return true;   
}


//! Opens a truth table file.
/*!
   \param fileName the file containing the truth tables.
   \return True iif the file was opened correctly.
*/
bool TruthTableDiskManager::openTables(wxString fileName)
{
    list<TruthTable *> *tableList = new list<TruthTable *>();
    filebuf fb;
    if (!fb.open (fileName.mb_str(), ios::in))
    {
        //cout << "Error opening the file" << endl;
        return false;
    }
    istream *is = new istream(&fb);
    int result;
    int inputs;
    int outputs;
    wxString name;
    FlexLexer* lexer = new yyFlexLexer();
    lexer->switch_streams(is, NULL);
    result = lexer->yylex();
    
    while (result != 0)
    {
        if (!((result == IDENTIFIER) || (result == UPPER) || (result == LOWER)))
        {
            //cout << "Identifier expected, file format error" << endl;
            delete tableList;
            delete is;
            delete lexer;
            fb.close();
            return false;
        }
        else
        {
            name = wxString(lexer->YYText(), wxConvUTF8);
            if (lexer->yylex() != NUMBER)
            {
                //cout << "Number expected, file format error" << endl;
                delete tableList;
                delete is;
                delete lexer;
                fb.close();
                return false;
            }
            else
            {
                inputs = atoi(lexer->YYText());
                if (lexer->yylex() != NUMBER)
                {
                    //cout << "Number expected, file format error" << endl;
                    delete tableList;
                    delete is;
                    delete lexer;
                    fb.close();
                    return false;
                }
                else
                {
                    outputs = atoi(lexer->YYText());
                    if (!readTable(name, inputs, outputs, tableList, lexer))
                    {
                        delete tableList;
                        delete is;
                        delete lexer;
                        fb.close();
                        return false;
                    }
                }
            }
        }
        
        result = lexer->yylex();
    }
    
    fb.close();
    returnTables(tableList);
    delete tableList;
    return true;
}


//! Reads a truth table from a stream.
/*!
   \param name the table name.
   \param inputs the table input number.
   \param outputs the table output number.
   \param tableList list of tables were the table read has to be appended.
   \param lexer the input stream.
   \return True iif the table was read correctly.
*/
bool TruthTableDiskManager::readTable(wxString name, int inputs, int outputs, list<TruthTable *> *tableList, FlexLexer *lexer)
{
    TruthTable *table = new TruthTable(name ,inputs, outputs);
    vector< vector<bool> > booleans;
    booleans.resize((int)(pow(2, (double)inputs)));
    for (unsigned int i = 0; i < booleans.size(); i++)
    {
        booleans[i].resize(outputs);
        for (unsigned int j = 0; j < booleans[i].size(); j++)
        {
            switch (lexer->yylex())
            {
                case NUMBER:
                {
                    if (atoi(lexer->YYText()) == 0)
                    {
                        booleans[i][j] = false;
                    }
                    else if (atoi(lexer->YYText()) == 1)
                    {
                        booleans[i][j] = true;
                    }
                    else
                    {
                        //cout << "1 or 0 expected, file format error" << endl;
                        delete table;
                        return false;
                    }
                    break;
                }
                default: //Error
                {
                    //cout << "1 or 0 expected, file format error" << endl;
                    delete table;
                    return false;
                }
            }
        }
    }
    table->setTable(booleans);
    tableList->push_back(table);
    return true;
}


//! Returns the tables to the controller.
/*!
   \param tableList the list of tables to return.
*/
void TruthTableDiskManager::returnTables(list<TruthTable *> *tableList)
{
    for(list<TruthTable *>::iterator i = tableList->begin(); i != tableList->end(); i++)
    {
        controller->newTable((*i));
    }   
}
