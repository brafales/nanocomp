/*
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
                                                                          */

// $Revision: 1.9 $

#include "forbiddenPatternDiskManager.hpp"
#include "flexDefines.hpp"
#include <list>
#include <fstream>


//! Constructor.
/*!
  \param controller the forbidden pattern controller.
*/
ForbiddenPatternDiskManager::ForbiddenPatternDiskManager(ForbiddenPatternManager *controller)
{
    this->controller = controller;
}


//! Destructor.
ForbiddenPatternDiskManager::~ForbiddenPatternDiskManager()
{
}


//! Saves a forbidden pattern collection to a file.
/*!
  \param FPs the forbidden pattern collection.
  \param fileName the file name to be saved.
  \return True if the file was correctly saved. False otherwise.
*/
bool ForbiddenPatternDiskManager::saveFPs(list<ForbiddenPattern*> FPs, wxString fileName)
{
    if (wxFile::Exists(fileName))
    {
        file.Open(fileName);
    }
    else
    {
        file.Create(fileName);   
    }
    file.Clear();
    if (!saveFPList(FPs))
    {
        file.Close();
        return false;
    }
    if (!file.Write(wxTextFileType_Unix))
    {
        file.Close();
        return false;
    }
    return (file.Close());
}


//! Private method. Saves a forbidden pattern collection to a file.
/*!
  \param FPs the forbidden pattern collection.
  \return True if the file was correctly saved. False otherwise.
*/
bool ForbiddenPatternDiskManager::saveFPList(list<ForbiddenPattern*> FPs)
{
    bool result = true;
    int FPId = 1;
    file.AddLine(_("#Forbidden Pattern file created by Nanocomp."));
    file.AddLine(_("#Do not edit this file if you don't know what are you doing."));
    file.AddLine(wxEmptyString);
    for(list<ForbiddenPattern*>::iterator i = FPs.begin(); i != FPs.end(); i++)
    {
        file.AddLine(wxString::Format(_("#Forbidden Pattern %d"), FPId));
        result = result && saveFP((*i));
        FPId++;
    }
    file.AddLine(_("#End of file"));
    return result;
}


//! Saves a forbidden pattern to a file.
/*!
  \param fp the forbidden pattern to be saved.
  \return True if the pattern was correctly saved. False otherwise.
*/
bool ForbiddenPatternDiskManager::saveFP(ForbiddenPattern *fp)
{
    file.AddLine(wxString::Format(_("%d %d"), fp->getWidth(), fp->getHeight()));
    file.AddLine(wxEmptyString);
    file.AddLine(_("!"));
    saveGrid(fp->getGrid());
    file.AddLine(wxEmptyString);
    return true;    
}


//! Saves a grid to a file.
/*!
  \param grid the grid to be saved.
  \return True if the grid was correctly saved. False otherwise.
*/
bool ForbiddenPatternDiskManager::saveGrid(Grid grid)
{
    wxString space = wxEmptyString;
    //Save the matrix. See the CA format documentation
    //for details.
    for(int i = 0; i < grid.getHeight(); i++)
    {
        wxString line = space;
        for(int j = 0; j < grid.getWidth(); j++)
        {
            wxString status;
             switch (grid(j, i))
            {
                case nDONTCARE:
                {
                    line = line + _(".");
                    break;
                }
                case nENABLED:
                {
                    line = line + _("1");
                    break;
                }
                case nDISABLED:
                {
                    line = line + _("0");
                    break;
                }
                default:
                {
                }
            }

            //Add the space between cells (except if last)
            if(j != grid.getWidth() - 1)
            {
                for (int l = 0; l < CELL_SPACE; l++)
                {
                    line += _(" ");
                }
            }
        }
        file.AddLine(line);
        //Add the line tabulation for each line
        for (int k = 0; k < LINE_SPACE; k++)
        {
            space += _(" ");
        }
    }
    return true;
}


//! Opens a forbidden pattern file.
/*! This method reads the patterns from the file
 * and calls the pattern controller for creation.
  \param fileName the file to be opened.
  \return True if the patterns were correctly opened. False otherwise.
*/
bool ForbiddenPatternDiskManager::openFPs(wxString fileName)
{
    //TODO change couts to GUI error messages
    //List where we'll store the patterns found
    list<ForbiddenPattern *> *FPList = new list<ForbiddenPattern *>();
    filebuf fb;
    if (!fb.open (fileName.mb_str(), ios::in))
    {
        cout << "Error opening file" << endl;
        return false;
    }
    istream *is = new istream(&fb);
    //Flex result
    int result;
    //Pattern width and height
    int width;
    int height;
    //Flex lexer
    FlexLexer* lexer = new yyFlexLexer();
    lexer->switch_streams(is, NULL);
    result = lexer->yylex();
    //We read until EOF
    while (result != 0)
    {
        if (result != NUMBER)
        {
            cout << "Number expected, file format error" << endl;
            //Clear all dynamic memory used since we have an error
            delete FPList;
            delete is;
            delete lexer;
            fb.close();
            return false;
        }
        else
        {
            //We've read the width
            width = atoi(lexer->YYText());
            if (lexer->yylex() != NUMBER) //Not another number
            {
                cout << "Number expected, file format error" << endl;
                //Clear all dynamic memory used since we have an error
                delete FPList;
                delete is;
                delete lexer;
                fb.close();
                return false;
            }
            else
            {
                //We've read the height
                height = atoi(lexer->YYText());
                if (lexer->yylex() != NEGATION)
                    {
                        cout << "! expected, file format error" << endl;
                        //Clear all dynamic memory used since we have an error
                        delete FPList;
                        delete is;
                        delete lexer;
                        fb.close();
                        return false;
                    }
                else
                {
                    //We try to read a grid
                    if (!readFP(width, height, FPList, lexer))//Wrong rule format
                    {
                        //Clear all dynamic memory used since we have an error
                        delete FPList;
                        delete is;
                        delete lexer;
                        fb.close();
                        return false;
                    }
                }
            }
            result = lexer->yylex();
        }
    }
    fb.close();
    //We return the patterns read to be added to the controller
    returnFPs(FPList);
    delete FPList;
    return true;
}


//! Reads a forbidden pattern from a file.
/*! Reads a pattern from the file and adds it to
 * the list of the patterns already read.
  \param width expected width of the pattern.
  \param height expected height of the pattern.
  \param FPList list of patterns where the read one has to be added.
  \param lexer Flex lexer.
  \return True if the pattern was correctly read. False otherwise.
*/
bool ForbiddenPatternDiskManager::readFP(int width, int height, list<ForbiddenPattern *> *FPList, FlexLexer *lexer)
{
    ForbiddenPattern *fp = new ForbiddenPattern(width, height);
    //Now we have to process width * height cells
    int result;
    for(int i = 0; i < width * height; i++)
    {
        switch (result = lexer->yylex())
        {
            case NUMBER: //Number, so must be 1 or 0, else error
                {
                    if (atoi(lexer->YYText()) > 1)
                    {
                        cout << "-, 1 or 0 expected, file format error" << endl;
                        delete fp;
                        return false;
                    }
                    else
                    {
                        if (atoi(lexer->YYText()))
                        {
                            cout << "Cell at position " << i/width << ", " << i - width * (i/width) << endl;
                            fp->cellChanged(i - width * (i/width), i/width, nENABLED);
                        }
                        else
                        {
                            cout << "No Cell at position " << i/width << ", " << i - width * (i/width) << endl;
                            fp->cellChanged(i - width * (i/width), i/width, nDISABLED);
                        }
                    }
                    break;
                }
            case POINT: 
                {
                    cout << "Don't care at position " << i/width << ", " << i - width * (i/width) << endl;
                    fp->cellChanged(i - width * (i/width), i/width, nDONTCARE);
                    break;
                }
            default: //Error
                {
                    cout << "-, 1 or 0 expected, file format error" << endl;
                    delete fp;
                    return false;
                }
        }
    }
    FPList->push_back(fp);
    return true;
}


//! Asks the controller to create the patterns.
/*! It takes a list of forbidden patterns read from
   a file and asks the pattern controller to add them
   to the collection.
  \param FPList list of patterns to be added.
*/
void ForbiddenPatternDiskManager::returnFPs(list<ForbiddenPattern *> *FPList)
{
    for(list<ForbiddenPattern *>::iterator i = FPList->begin(); i != FPList->end(); i++)
    {
        controller->newFP((*i));
    }   
}
