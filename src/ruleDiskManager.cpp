/*
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
                                                                          */

// $Revision: 1.16 $

#include <list>
#include <fstream>
#include "flexDefines.hpp"
#include "ruleDiskManager.hpp"

using namespace std;

//! Constructor
/*!
   \param controller the rule controller.
*/
RuleDiskManager::RuleDiskManager(RuleManager *controller)
{
    this->controller = controller;
}


//! Destructor
RuleDiskManager::~RuleDiskManager()
{
}


//! Saves a rule collection to a file.
/*!
   \param rules the rule collection.
   \param fileName the file to save.
   \return True iif the rules were correctly saved.
*/
bool RuleDiskManager::saveRules(list<Rule*> rules, wxString fileName)
{
    if (wxFile::Exists(fileName))
    {
        file.Open(fileName);
    }
    else
    {
        file.Create(fileName);   
    }
    file.Clear();
    if (!saveRuleList(rules))
    {
        file.Close();
        return false;
    }
    if (!file.Write(wxTextFileType_Unix))
    {
        file.Close();
        return false;
    }
    return (file.Close());
}


//! Saves a rule list to the file.
/*!
   \param rules the rule list.
   \return True iif the rule list was saved correctly.
*/
bool RuleDiskManager::saveRuleList(list<Rule*> rules)
{
    bool result = true;
    int ruleId = 1;
    file.AddLine(_("#Rule file created by Nanocomp."));
    file.AddLine(_("#Do not edit this file if you don't know what are you doing."));
    file.AddLine(wxEmptyString);
    for(list<Rule*>::iterator i = rules.begin(); i != rules.end(); i++)
    {
        file.AddLine(wxString::Format(_("#Rule %d"), ruleId));
        result = result && saveRule((*i));
        ruleId++;
    }
    file.AddLine(_("#End of file"));
    return result;
}


//! Saves a rule to the file.
/*!
   \param rule the rule to save.
   \return True iif the rule is saved correctly.
*/
bool RuleDiskManager::saveRule(Rule *rule)
{
    file.AddLine(wxString::Format(_("%d %d"), rule->getWidth(), rule->getHeight()));
    file.AddLine(wxEmptyString);
    saveGrid(rule->getInitialGrid());
    file.AddLine(wxEmptyString);
    saveGrid(rule->getFinalGrid());
    file.AddLine(wxEmptyString);
    return true;    
}


//! Saves a grid to the file.
/*!
   \param grid the grid to save.
   \return True iif the grid is saved correctly.
*/
bool RuleDiskManager::saveGrid(Grid grid)
{
    wxString space = wxEmptyString;
    for(int i = 0; i < grid.getHeight(); i++)
    {
        wxString line = space;
        for(int j = 0; j < grid.getWidth(); j++)
        {
            switch (grid(j, i))
            {
                case nENABLED:
                {
                    line = line + _("1");
                    break;
                }
                case nDISABLED:
                {
                    line = line + _("0");
                    break;
                }
                case nDONTCARE:
                {
                    line = line + _(".");
                    break;
                }
                default:
                {
                }
            }
            
            //Add the space between cells (except if last)
            if(j != grid.getWidth() - 1)
            {
                for (int l = 0; l < CELL_SPACE; l++)
                {
                    line += _(" ");
                }
            }
        }
        file.AddLine(line);
        //Add the line tabulation for each line
        for (int k = 0; k < LINE_SPACE; k++)
        {
            space += _(" ");
        }
    }
    return true;
}


//! Opens a rules file.
/*!
   \param fileName the rules file.
   \return True iif the file was opened correctly.
*/
bool RuleDiskManager::openRules(wxString fileName)
{
    list<Rule *> *ruleList = new list<Rule *>();
    filebuf fb;
    if (!fb.open (fileName.mb_str(), ios::in))
    {
        //cout << "Error opening the file" << endl;
        return false;
    }
    istream *is = new istream(&fb);
    int result;
    int width;
    int height;
    FlexLexer* lexer = new yyFlexLexer();
    lexer->switch_streams(is, NULL);
    result = lexer->yylex();
    while (result != 0)
    {
        if (result != NUMBER)
        {
            //cout << "Number expected, file format error" << endl;
            delete ruleList;
            delete is;
            delete lexer;
            fb.close();
            return false;
        }
        else
        {
            width = atoi(lexer->YYText());
            if (lexer->yylex() != NUMBER) //Not another number
            {
                //cout << "Number expected, file format error" << endl;
                delete ruleList;
                delete is;
                delete lexer;
                fb.close();
                return false;
            }
            else
            {
                height = atoi(lexer->YYText());
                if (!readRule(width, height, ruleList, lexer))//Wrong rule format
                {
                    delete ruleList;
                    delete is;
                    delete lexer;
                    fb.close();
                    return false;
                }
            }
            result = lexer->yylex();
        }
    }
    fb.close();
    returnRules(ruleList);
    delete ruleList;
    return true;
}


//! Reads a rule from a stream.
/*!
   \param width expected rule width.
   \param height expected rule height.
   \param ruleList rule list where the read rule should be appended.
   \param lexer the input stream.
   \return True iif the rule was correctly read.
*/
bool RuleDiskManager::readRule(int width, int height, list<Rule *> *ruleList, FlexLexer *lexer)
{
    Rule *rule = new Rule(width, height);
    //Now we have to process width * height * 2 cells
    //First rule
                for(int i = 0; i < width * height; i++)
                {
                    switch (lexer->yylex())
                    {
                        case NUMBER: //Number, so must be 1 or 0, else error
                            {
                                if (atoi(lexer->YYText()) > 1)
                                {
                                    //cout << "-, 1 or 0 expected, file format error" << endl;
                                    delete rule;
                                    return false;
                                }
                                else
                                {
                                    if (atoi(lexer->YYText()))
                                    {
                                        //cout << "Cell at position " << i/width << ", " << i - width * (i/width) << endl;
                                        rule->cellChanged(i - width * (i/width), i/width, nENABLED, nINITIAL);
                                    }
                                    else
                                    {
                                        //cout << "No Cell at position " << i/width << ", " << i - width * (i/width) << endl;
                                        rule->cellChanged(i - width * (i/width), i/width, nDISABLED, nINITIAL);
                                    }
                                }
                                break;
                            }
                        case POINT: 
                            {
                                //cout << "Don't care at position " << i/width << ", " << i - width * (i/width) << endl;
                                rule->cellChanged(i - width * (i/width), i/width, nDONTCARE, nINITIAL);
                                break;
                            }
                        default: //Error
                            {
                                //cout << "-, 1 or 0 expected, file format error" << endl;
                                delete rule;
                                return false;
                            }
                    }
                }

                for(int i = 0; i < width * height; i++)
                {
                    switch (lexer->yylex())
                    {
                        case NUMBER: //Number, so must be 1 or 0, else error
                            {
                                if (atoi(lexer->YYText()) > 1)
                                {
                                    //cout << "-, 1 or 0 expected, file format error" << endl;
                                    return false;
                                }
                                else
                                {
                                    if (atoi(lexer->YYText()))
                                    {
                                        //cout << "Cell at position " << i/width << ", " << i - width * (i/width) << endl;
                                        rule->cellChanged(i - width * (i/width), i/width, nENABLED, nFINAL);
                                    }
                                    else
                                    {
                                        //cout << "No Cell at position " << i/width << ", " << i - width * (i/width) << endl;
                                        rule->cellChanged(i - width * (i/width), i/width, nDISABLED, nFINAL);
                                    }
                                }
                                break;
                            }
                        case POINT:
                            {
                                //cout << "Don't care at position " << i/width << ", " << i - width * (i/width) << endl;
                                //Same as the initial grid
                                int initialStatus = rule->getInitialGrid()(i - width * (i/width), i/width);
                                rule->cellChanged(i - width * (i/width), i/width, initialStatus, nFINAL);
                                break;
                            }
                        default: //Error
                            {
                                //cout << "-, 1 or 0 expected, file format error" << endl;
                                return false;
                            }
                    }
                }
                ruleList->push_back(rule);
                return true;
}


//! Returns the rules to te controller.
/*!
   \param ruleList list of rules to be returned.
*/
void RuleDiskManager::returnRules(list<Rule *> *ruleList)
{
    for(list<Rule *>::iterator i = ruleList->begin(); i != ruleList->end(); i++)
    {
        controller->newRule((*i));
    }   
}
